So now let's talk about object encryption

in Amazon S3.

So you can encrypt objects in S3 buckets using one

of the following four methods.

The first one is server-side encryption, SSE,

and you have multiple flavors of it.

So you have SSE-S3,

which is server-side encryption with Amazon S3-managed keys,

and that is enabled by default

for your buckets and your objects.

Then we have SSE-KMS, where we encrypt this time

with a KMS key to manage the encryption key.

Then we have SSE-C to use customer-provided key,

so this time we provide the own encryption key.

And don't worry, we'll see all of these

in great details in the next slide,

so this is just an overview.

And then we have client-side encryption

when we want to encrypt everything client side

and then upload it to Amazon S3.

So at the exam it's important to understand

which ones are for which situation,

so let's do a deep dive into all of those

and understand the specificities of them.

So the first one is Amazon S3 for SSE-S3 encryption.

So in this case, the encryption is using a key

that's handled, managed and owned by AWS.

You never have access to this key.

The object is going to be encrypted server side by AWS

and the security type of the encryption is a AES-256.

Therefore, you must set the header

to "x-amz-server-side-encryption": "AES256"

to request Amazon S3 to encrypt the object

for you using the SSE-S3 mechanism.

Now SSE-S3 is enabled by default

for new buckets and new objects.

So how does that work?

We have Amazon S3, and we have our user.

The user, you, you're going to upload a file

with the correct header,

and then it will be an object under Amazon S3.

Amazon S3 will pair it with the S3-owned key, okay,

because we're using the SSE-S3 mechanism.

And then we'll perform encryption

by mixing the key and the object,

and that will be what will be stored on your S3 buckets.

So that's for the simpler one, SSE-S3.

Then we have SSE-KMS.

So this time, instead of relying on the key

that is owned by AWS and the S3 service,

you want to manage your own keys yourself using

the KMS service, the Key Management Service.

So the advantages using KMS

is that you have user control over this key,

so you can create keys yourself within KMS,

and you can edit the key usage using CloudTrail.

So anytime someone uses a key in KMS,

this is going to be logged in a service

that logs everything that happens in AWS called CloudTrail.

So for this, we must have a header called

the "x-amz-server-side-encryption": "aws:kms"

and then the object will be encrypted server side.

So anything SSE, of course, is server side.

So how does that work?

Well, again, we upload the object,

this time with a different header,

and in the header we actually specify

the KMS key we want to use.

Then the object is appearing in Amazon S3,

and this time the KMS key that's going to be used

is coming out of the AWS KMS.

So these two things together are going to be blended

and then you're gonna get encryption,

and that's the file is going to end up in the S3 buckets.

So now to read that file from the S3 bucket,

not only do you need access to the object itself

but also to the underlying KMS key that was used

to encrypt this object.

So this is another level of security.

So SSE-KMS has some limitations

because while now that you upload

and download files from Amazon S3,

you need to leverage a KMS key.

The KMS key has its own APIs, for example,

GenerateDataKey, and when you decrypt,

you're going to use the Decrypt API, and so therefore,

you're going to do API calls into the KMS service.

Each of these API calls is going to count

towards the KMS quotas of API calls per second,

so based on the region,

you have between 5,000 and 30,000 requests per second,

although they can be increased using

the Service Quotas Console.

And so if you have a very, very high throughput S3 bucket,

and everything is encrypted using KMS keys,

you may go into a thread link kind of use case.

So this is something the exam may test you on.

Next we have the SSE-C type of encryption.

So this time the keys are managed outside of AWS,

but it still server-side encryption

because we send the key to AWS.

But Amazon S3 will never store

the encryption key you provide.

After they're used, they're being discarded.

So in that case, because we transmit a key into Amazon S3,

we must use HTTPS and we must pass the key

as part of HTTP headers for every request being made.

So how does that work?

The user is going to upload a file as well as the key,

but the user manages the key outside of AWS.

Then, Amazon S3 will use the client's provided key

and the object to perform some encryption

and then put the file as encrypted into an S3 bucket.

And of course, to read that file,

the user must again provide the key

that was used to encrypt that file.

Finally, we have the client-side encryption.

So this is easier to implement

if we leverage some client library

such as the Client-Side Encryption Library.

And the idea with client-side encryption

is that the clients must encrypt data themselves

before sending data to Amazon S3.

And also, you can retrieve the data from Amazon S3,

and then the decryption of the data happens

on the client outside of Amazon S3.

Therefore the clients fully manages the keys

and the encryption cycle.

So how does that work?

We have a file and we have a client's key

that's outside of AWS.

The client itself is going to provide

and perform the encryption,

so now we have an encrypted file,

and that file as is can be sent into Amazon S3 for upload.

So we've seen all the levels of encryption of objects,

but now let's talk about encryption in transit.

So encryption in transit, or in flight,

is also called SSL or TLS,

and basically your Amazon S3 bucket has two endpoints,

the HTTP endpoint that is not encrypted

and the HTTPS endpoint that has encryption in flights.

So anytime you visit a website

and you see that green lock or lock,

usually that means it's using encryption in flights,

meaning the connection between you

and the target server is secure and fully encrypted.

Therefore, when you're using Amazon S3,

it's fully recommended to use HTTPS

to have secure transmission of data, of course,

and if you use the SSE-C type of mechanism,

you must use the HTTPS protocol.

Now this is not something to worry about in real life

because while most clients would use

the HTTPS endpoint by default.

Now how would you go about forcing encryption in transits?

For this, we could use a bucket policy.

So you attach a bucket policy to your S3 bucket,

and you attach this statement which is saying

that you deny any GetObject operation

if the condition is "aws:SecureTransport": "false".

So SecureTransport is going to be true whenever using HTTPS

and false whenever you're not using an encryption,

an encrypted connection,

and so, therefore, any user trying to use HTTP

on your bucket is going to be blocked,

but users using HTTPS may be allowed.

Okay, so that's it for encryption,

I hope you liked it, and I will see you in the next lecture.

So let's practice encryption.

And for this I'm going to create a bucket

called demo-encryption-stephane-v2.

And we scroll down,

we're going to leave this on, leave this on.

We're going to enable bucket versioning.

And then under default encryption, as we can see,

we have three different options

but we must choose a default encryption for our buckets.

So I will go over SSE-S3 right now

and we'll have a look at SSE-KMS and DSSE-KMS later on.

So let's click on Create a bucket.

And now we have created a bucket

that has default encryption turn on.

So let's verify this by actually uploading an object.

So we're going to add a file

and we'll add our coffee.jpg file.

And then we're going to just click on Upload.

And as you can see now I can click on this file

and scroll down,

look for the server side encryption settings.

And indeed the file was encrypted

with server side encryption

with Amazon S3 managed keys, so SSE-S3.

We can also edit the encryption mechanism for a file.

So I could just click on Edit.

And as you can see,

if we do edit the server side encryption,

then this will create a new version

of the object with updated setting.

And so therefore, this is why I have enabled versioning

for my bucket, is to show you

that a new version of the file will be created.

So let's change the encryption.

And for this, we're going to override the bucket settings

for default encryption for this one object.

And so we have a choice to use

either SSE-KMS or DSSE-KMS.

So DSSE-KMS, I won't spend a lot of time on this.

It's just two level of encryptions on KMS.

So just a stronger KMS.

We're just going to use KMS right now.

It is simpler and it is not going to cost us any money.

So we're going to use SSE-KMS as we learned.

And then we have to specify a KMS key.

So we can either enter a KMS key ARN,

or we can choose from your own KMS keys.

So if we choose from the KMS keys right now,

you should have only one key available

the AWS/S3 key, and it's called the default KMS key

for the S3 service.

So if you click on it, we can use this key.

And that's not going to cost us any money

because this is the default key for the service.

If you created your own KMS key,

then it would be available in this list.

But creating your own KMS key

will cost you some money every month.

So for this purpose, we're just going

to use the default AWS/S3 KMS key.

Okay, so let's save the changes.

We close this, and now if we go under Versions,

as we can see, we have two versions

of our file right now available.

And so the current version, if we scroll down

and go under service side encryption,

as we can see it is indeed encrypted with SSE-KMS

with this encryption key, which corresponds

to the default AWS/S3 KMS key.

Okay, so this is really good.

Next we go under this part.

So we can do the same process by uploading a file

and then we're going to add a file, for example, beach.jpg.

And under Properties,

we're going to find server side encryption.

And here we can specify an encryption key

to either use the default encryption mechanism

or to override it with SSE-S3, SSE-KMS or DSSE-KMS.

So this is one way of doing it.

And finally, let's have a look

at the default encryption properties.

So let's scroll down

and we're going to find default encryption.

Let's edit this, and here we have the option.

So we can enable SSE-S3, SSE-KMS

as the default encryption, or DSSE-KMS.

So in case we do SSE-KMS,

we have the bucket key option available to us.

So this is to reduce the cost

by doing less API calls to AWS KMS.

And so this is enabled by default.

If we just use SSE-S3, then this setting doesn't count.

So we've seen

that we can change the default encryption here.

And you may ask me, well, SSE-C is missing.

Well, indeed it is missing

because SSE-C you can only do from the CLI,

not from the console.

So that means that you cannot enable SSE-C right here.

And finally, for client side encryption,

while you have to encrypt everything client side,

then upload it to AWS and then decrypted client side,

and so you don't need to tell AWS

that the data is client side encrypted.

So therefore, the only options you can deal with

in the console are SSE-S3, SSE-KMS and DSSE-KMS.

So that's it, we've seen all the encryption options in AWS.

I hope you liked it, and I will see you in the next lecture.

# S3 Default Encryption

So just a short lecture

on default encryption versus bucket policies.

So by default

now all buckets are having a default encryption of SSE-S3.

So it's applied automatically

to new objects toward the new buckets.

But you can change this

to be a different default encryption, for example, SSE-KMS.

Nonetheless, you can also force encryption

by using a bucket policy to refuse any API call

to put an S3 object without the correct encryption headers.

So for example, SSC-KMS or SSE-C.

So this is the kind of bucket policies

you could have in, for example,

this one is saying, hey, if you do a PUT object

but you don't have the encryption header that says AWS KMS,

then deny this request.

Or, hey, if you are uploading this

but there is no customer side algorithm, so no SSE-C,

then deny this object.

So this is just an example,

but at least you see that a bucket policy

can also force a way to have encryption in your buckets.

And by the way, bucket policies are always going

to be evaluated before your default encryption settings.

So that's it, just remember, default encryption

is on by default with SSC-S3 but you can change it

and you can apply a bucket policy preemptively

to force encryption to the one you want.

Alright, that's it.

I hope you liked it and I will see you in the next lecture.