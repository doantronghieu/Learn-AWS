Now let's talk

about Dead Letter Queues in SQS.

The idea is that let's get into the scenario

where a consumer fails to process a message

within the visibility timeout period.

Then we know that the message

automatically goes back into the queue.

So the consumer reads the message,

maybe there's a failure,

maybe we don't have enough time.

The message goes back into the queue.

Now, if that thing happens very often,

that can be a problem.

For example, we read again the message,

maybe there's something wrong with the message.

Maybe our consumer doesn't understand the message

or can't process the message.

Then the message will go back into the queue

and it will happen again.

We'll read the message again from SQS

and it will go again back into the queue.

So we can set a threshold

to how many times this can happen.

And,

this failure loop can be a big problem,

but we can set a MaximumReceives threshold.

And if that threshold is exceeded

then we can tell SQS to say,

"Well, this message looks a bit odd.

It looks like it's being processed too many times

and not successfully."

Therefore, send this into a Dead Letter Queue.

And the Dead Letter Queue will contain that message

and for later processing.

And so the message will be removed

from the first queue and sent into the second one.

Why do we have Dead Letter Queues?

Well Dead Letter Queues are very useful for debugging

and in case a message goes in Dead Letter Queue

because it is an SQS queue, you have to process it,

but at least it gives you time

to understand what is happening.

Few things to notice that the Dead Letter Queue

of a FIFO queue must also be a FIFO queue,

and the Dead Letter Queue of the Standard queue

must also be a Standard queue.

Finally, because we have a Dead Letter Queue, you need to

make sure that the messages are processed before

They expire

from the queue.

So it's a good idea to set a long time

for example, 14 days of retention

from

within the Dead Letter Queue.

And the next feature for management

of your Dead Letter Queues are the re drive to

source feature.

So it's a feature to help you consume messages in

the Dead Letter Queue to understand what is wrong with them.

So you have your messages

now you know they haven't been processed in the source queue

and therefore they are in the Dead Letter Queue

and you're going to do a manual inspection

and debugging of these messages.

And then you're going to fix your consumer code

understand why the message wasn't processed

in case the message was correct.

And then what you can do is re drive that message

from the dead letter queue into the source SQS queue

And what's going to happen with this is

that the consumer can now reprocess that message

without even knowing that the message went

into the Dead Letter Queue

and then the message processing has happened

and as a cool feature.

So now let us go into the console

so I can show you the Dead Letter Queue feature.

So let's go ahead and create

a dead-letter queue for my demo queue.

So I'll call this one DemoQueueDLQ.

I will scroll down, and because it's a dead-letter queue,

I wanna give myself ample time

to retain and to analyze messages.

So I'll have a 14 days message retention period.

Okay, perfect.

So let's scroll down.

We'll have a default encryption enabled.

Everything looks good here

and we're going to create this queue.

So now that this queue has been successfully created,

let's go and open a new tab

and go into the configuration of my DemoQueue.

So here, I'm going to edit the queue itself

and the visibility timeout is going to be set

to something really slow, really low, sorry,

to go and be a bit faster in my demo.

So we'll have it as five seconds

to read the messages three times very quickly.

And then if I scroll down under Dead-letter queue

I can enable it

and I can choose the DemoQueueDLQ as QSQ

as my dead-letter queue.

Now we need to specify the maximum receive.

So this is how many times the message should be received

before it ends up being in the DLQ.

And to be a bit quicker, we're saying three.

So after the message is read three times

and put back into the queue a fourth time,

then it's going to end up into my SQS DLQ.

So let's save this, and we're good.

So now I'm going to go to my DLQ

and I'm going to start to receive messages

and start to poll for messages.

And right now, of course,

we don't have any messages in my DLQ,

but let's go to my normal queue right now

and I'm going to send and receive messages.

And this one's going to be

hello world, poison pill.

Poison pill, because it's actually going to

make my consumer application fail.

So that's why it's called a poison pill

but we don't have any consumer application.

This is just a consumer application itself.

So let's send the message.

The message has been sent.

And now let's poll for messages.

So here we're receiving the messages once

and after five seconds, we will receive it a second time.

And after, again, five seconds,

we're going to receive a third time,

as you can see right here.

And after the message being received three times,

well, because it's always being put back in the queue,

it's not being dismissed,

then the message is going to be sent to the DLQ.

So let's verify this.

Now, if I just stop polling right now

and I try to poll again for new messages,

I will see that I don't receive the message anymore.

So where has the message gone?

Well, if we go into the DLQ itself,

so this is my DLQ,

and I poll for messages,

as you can see, I see the message in my DLQ right now.

And this message, if I click on it as my DLQ,

I can say "Okay, I have a look at this message

and this message is why my main application crashed."

Finally, let me show you how to redrive that message

from the DLQ into this first queue.

In case, for example, we fixed our consumer application.

So in my DLQ, I'm gonna go right here

and on the top right corner

there is a Start DLQ redrive.

So we're saying, "Hey, this is a DLQ

and you received messages."

And so you wanna redrive these messages

to the source queue.

So we just click on this option.

For velocity control, we'll have Systemoptimized,

and then we can inspect messages if we wanted to.

Then we just click on DLQ redrive.

So it's called a DLQ redrive task.

And if I go here,

I can see that it's already been successfully completed.

So this means that if I go back into my DemoQueue,

the source queue,

and go into Send and receive messages,

and poll for messages,

as you can see, the message reappeared right here.

And so therefore, the redrive has worked.

So hopefully that gives you a good overview

into how dead-letter queues work.

I hope you liked it,

and I will see you in the next lecture.