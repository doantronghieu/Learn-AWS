So now that

we've seen synchronous invocations,

let's go into asynchronous invocation.

So they're for service

that will invoke another functions behind the scenes,

so Amazon S3, SNS topics, CloudWatch Events, and so on.

So let's go through a concrete example.

Say we have an S3 bucket

and an S3 event notification for new files.

This will go into the Lambda Service,

and because it's asynchronous something will happen.

The events are going to be placed

in an internal Event Queue.

So we have an Event Queue here

and your Lambda function is going to

be reading off that Event Queue.

The Lambda function then will try to process these events,

but if somehow things go wrong,

the Lambda function will automatically attempt to retry.

So that means that it will be three tries in total.

The first one will happen right away,

then the second one will happen a minute after,

and the third one will happen two minutes after

the second one.

So the idea is that our Lambda function

is going to retry three times in total.

And then, once the retries happen,

that means that our Lambda function is possibly

going to process those same events multiple times

and so this could be a problem.

And so if you lambda function is not idempotent

this could be big problem, so meaning your Lambda function

should be idempotent.

Idempotentcy means that, in case of retries,

the result is the same.

So then, if you have a retry happening,

what will happen is that you will see

duplicate log entries in CloudWatch Logs

because your Lambda function

will try over and over and over again.

So we can define a DLQ, or dead-letter queue,

for after the retries are done.

So that means that in case there's a failed processing

and we never were able to succeed

because of the retries, then the Lambda function

can send some events to SQS or SNS

for further processing later one.

And so, this is the whole idea

behind asynchronous invocations.

And so you may ask me,

"Why we will use asynchronous versus synchronous?"

Well, first of all, some services must use asynchronous,

so you have no choice,

and the second one is, for example,

say you need to speed up processing

and you don't need to wait for the results,

then you can start 1000 files being processed

at the same time, and you just wait at the end

for all five to be processed in parallel,

but you don't wait for each individual results,

and so that speeds up your processing time.

So, what services are done asynchronously?

The first one is Amazon S3

when we have S3 Event Notifications

invoking Lambda functions.

We have SNS, so when we receive notifications

and we trigger a Lambda function.

CloudWatch Events or CloudWatch EventBridge,

which will basically have our Lambda functions

react to events happening in our AWS infrastructure.

Other services that we will not necessarily see

in the hands-on would be CodeCommit

to trigger a Lambda function whenever

there's a new branch or new tag or new push,

CodePipeline to invoke a Lambda function during the pipeline

and the Lambda must callback CodePipeline,

or some other services, CloudWatch Logs for log processing,

SES, so Simple Email Service for sending out emails,

CloudFormation, Config, Io T, and IoT Events.

So from our standpoint for this certification

we need to know how Lambda works with Amazon S3,

SNS, and CloudWatch Events or EventBridge.

So let's go ahead and learn

about asynchronous invocation in the hands-on.

I will see you in the next lecture.

# Lambda Asynchronous Invocations Hands On.

Okay. So I have my demo-lambda function

that I want to invoke asynchronously this time.

So if we look at the code again,

it will print some values

then it will return the event key1.

But if we invoke this asynchronously,

we cannot do it from the console,

we have to do it from the CLA.

So let's open CloudShell.

And so the whole purpose of an asynchronous invocation

is that we do not have the results back to us.

So let's copy this entire command right here.

So I paste a command and press enter.

And my lambda function has now been invoked,

and we get a status code 202 as a result.

So that means that the lambda function

has been successfully invoked

but we don't know the results.

And so to look at the result what we could do

is we look at the CloudWatch logs.

So if you go under monitor and look at the CloudWatch logs

we can look at the recent invocations.

And then if we look at

one that will appear very soon hopefully.

So let's go into here,

and we look at the log groups,

and we look at this one,

here we go that's my latest invocation.

As we can see the function was invoked

and the requests was successful.

But we don't know this,

if it was successful or not,

thanks to this command,

because this was an asynchronous invocation.

And we can do it for sure

because if we go into our Lambda function

and we're going to change the code to make it fail.

So I will comment the return

and I will uncomment the raise exception.

I'll deploy to save my changes.

Now if we test this function,

we know it fails.

It's just failed right now.

But if we use CloudShell again,

our CLI to invoke the function,

we get again a 202 status code for the error.

And I can know for sure that it has failed

because if I go into my log stream

and open this log stream,

we get an error right here.

So as we can see invoking the function asynchronously

returns the same status code 202

regardless of whether or not

the function succeeded or failed

because we don't want to know the results,

due to the nature of asynchronous.

So what we can do instead

is maybe set up a dead letter queue.

So if we go into our lambda function

and go to configurations,

under asynchronous invocations we have some information

and we can edit some configuration

around a dead letter queue.

So we have 0, 1 or 2 retry attempts

on the failure of an asynchronous event.

So we'll keep it as 2.

And then we can send the unprocessed events

from an asynchronous invocation

into a dead-letter queue.

So we can choose SQS

and we need to create an SQS queue for this.

So let's go into the SQS service,

and I'm going to create a queue,

and its going to be a standard queue called lambda-DLQ.

And I will click on create queue.

Now my lambda-GLQ has been created.

So let's go back into here and refresh this.

And now I need to refresh this page probably.

So let's refresh it,

edit the letter queue service SQS

and queue lambda-GLQ.

Here we go, it's appearing.

Save. And as we can see we can't save it

because the function does not

have enough permissions to call send message on SQS.

And so to fix that

we need to fix the IM role of our lambda function.

So if you go into our lambda function,

we go into our configuration

and general configuration permissions, sorry,

here is the execution role.

So we click on it,

so we're taking into the IM console,

and I'm going to attach a policy to it.

I will look for the SQS type of policy

and I will just give it,

the AmazonSQSFullAccess is going to be easy, at least.

And this way we are sure

that our lambda function can write into our SQS queue.

So back into our lambda console,

under the configuration for asynchronous,

we scroll down,

we save and this time,

yes it completes

and now my lambda function can write into SQS.

So, if we try to go now into our CloudShell,

and invoke this function again,

we'll know that the invocation itself will fail

because the lambda function function was coded to fail.

But now what's going to happen is that

the DLQ is going to kick into effect,

so we're gonna have 2 retry attempts,

and after the retry attempts have failed

then the message should go into Amazon SQS.

So right now if you're going to Amazon QS,

and we're going to send and receive messages

and look at the messages available.

We can pull from messages.

We have one message available.

This was just a test for the lambda function,

just to test whether or not

it was able to send some data into SQS.

So what I can do is that I can just

delete that message right here.

And now I'm going to wait 4 minutes

to see if my lambda function

sends a message to SQS due to the retries.

So let me pause the video and get back to you.

Okay, so now if I go into my CloudWatch logs,

and look at this log stream,

we can see something interesting.

So there is a request ID that surfaces 2ab,

and it's failed.

Then if we scroll down,

there is another request with 2ab,

so the same request ID,

and then it failed.

So that was the first retry.

And then there's another request with 2ab,

then it failed and that was the secondary retry.

So then the message went into the DLQ.

And so if we go into SQS and pull for messages,

we can see this message right here has failed.

And we can look at the key and the value,

and this was all the information around the message.

And if we look at the attributes of the message itself,

we can see that the error cause is 200,

something went wrong

and the request ID has 2ab in it,

so this corresponds to the invocation ID in lambda

that we can get directly from the message attributes in SQS.

So this really shows

that the asynchronous invocation and the DLQ work as well.

So this is for this hands-on.

I hope you liked it,

and I will see you in the next lecture.
