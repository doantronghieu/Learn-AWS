# Serverless Introduction.

Okay, so let's discuss now

what is serverless.

So serverless is something new.

And the developers when you use serverless services,

you don't have to manage servers anymore.

So it's not that you don't have servers anymore,

it's just that you don't manage them.

You just deploy code

and originally, you just deploy it functions.

So initially serverless meant Function as a Service,

or FaaS.

But now serverless means a lot more.

So in the beginning,

serverless was pioneered by AWS Lambda

that we'll see in the section,

but now also includes anything that is remotely managed.

So databases, messaging, storage,

as long as you don't provision servers.

So serverless doesn't mean there are no servers,

it just means you don't see them

or you don't provision them.

So if we drill down into what serverless means,

in AWS, we have our users

and they would get for example,

static content for from our S3 buckets

delivered as a website's

or CloudFront plus S3.

Then we would login with cognito,

this is where our users would have their identity stored.

And they would invoke your REST API

through the API gateway,

the API gateway would invoke Lambda functions,

and Lambda functions would store

and retrieve data from DynamoDB.

So this is just an example.

This section is going to be dedicated to

learning a lot of things around Lambda DynamoDB,

API Gateway, Cognito, and so on.

But so it's just to give you an a reference architecture

for serverless applications.

So in AWS, it's Lambda DynamoDB, Cognito, API Gateway,

Amazon S3,

but also things we've already seen such as

SNS and SQS,

yes indeed,

we did not manage any servers for SQS and SNS

and it was scaling on its own.

So that fits the serverless use case

Kinesis Data Firehose, because again

it scales

based on the throughput you have

you just pay for what you use

and you don't provision servers,

Aurora Serverless,

when your Aurora database

scales on demand

without you managing servers,

step functions and fargate

because fargate was a serverless function of ECS,

where we didn't provision the infrastructure

to run our Docker containers.

So hopefully this is short

and sweet introduction to serverless.

Next lecture, we'll be starting with AWS lambda.

And it will be a lot of content to learn,

but the exam does test you heavily

on your serverless knowledge.

So let's get started.

#  AWS Lambda Overview

So what is AWS Lambda and why is it helpful for us?

So let's take an example.

We are going to start with Amazon EC2.

And Amazon EC2, as we know,

they are virtual servers in the cloud

and we have to provision them,

so we are limited by the amount

of memory and CPU we're going to provision.

They have to be continuously running,

I mean, we can optimize them

by starting them and stopping them efficiently,

but otherwise they run continuously,

regardless of if something's happening

or not on your instance.

And if you want to scale, you can use auto scaling groups,

but that means that you need to do something to

automatically add and remove servers.

Now, this is one way of doing things

and it has worked great.

But then there is AWS Lambda.

So with Lambda, these are visual functions.

No servers to manage.

So that means that we just provision the code

and the functions run.

It is limited by time,

so we're talking about short executions

of up to 15 minutes, which is in my opinion,

not that short.

And then finally they run on-demand.

So that means that when you don't use Lambda,

your Lambda function is not running,

and you only are going to be billed

when your function is running.

And it will run on demand when it gets invoked,

which is a huge shift from Amazon EC2.

Finally, the scaling is automated.

If you need more than the functions, occurrences,

and the concurrency, then automatically AWS will provision

for you more Lambda functions. Magical.

We'll see this in the hands-on.

So benefits of Lambda.

I'm sure you see many.

First of all the pricing is super easy.

You're going to pay

for the number of requests Lambda receives,

so the number of invocations,

and your computer time,

so how long Lambda was running for.

There is a very generous free tier on Lambda,

which is 1 million Lambda requests

and 400,000 gigabytes seconds of compute time.

It is also integrated

with so many A-list services as we'll see.

And we can use a lot of different programming

languages on Lambda, so we're quite free.

And there's very easy monitoring

integrations with CloudWatch.

Finally, if you wanted to provision

more resources per function,

you can provision up to 10 GB

of RAM per function, which is a lot.

And by the way, you need to know this:

if you increase the RAM of your function,

then it will also improve the quality

and performance of your CPU and network, so.

Now let's talk about the language supports for Lambda.

We have node.js, for JavaScript,

Python, Java which is Java 8 compatible or Java 11,

C# for .NET Core, Golang, C# for Powershell,

Ruby, and you can write pretty much any language for Lambda

thanks to the custom runtime API

which is community supported.

And, for example, if you wanted to run

Rust language functions on Lambda,

it is possible thanks to an open source project.

So Lambda has a lot of language support.

And it also has support for the Lambda container image.

So this Lambda container image is quite special.

The container image itself must implement

the Lambda runtime API,

so it's not any container image that can run on Lambda.

There needs to be some prerequisites

about how that container image is built.

And then ECS and Fargate is going still to be preferred

for running arbitrary Docker images.

So the exam, if they ask you to run a container on Lambda,

unless that container does implement the Lambda runtime API,

you will run to run that container on ECS or Fargate.

Now, I said that Lambda was integrated

with so many A-list services.

So I'll give you a few

and some idea of how, how they're integrated.

And in this course, we will see some of these integrations.

So API Gateway is to create a REST API,

and they will invoke our Lambda functions.

Kinesis will be using Lambda

to do some data transformations on the fly.

DynamoDB will be used to create some triggers,

so whenever something happens in our database

a Lambda function will be triggered.

Amazon S3, we've seen this already.

A Lambda function would be triggered anytime,

for example, a file is created in S3.

CloudFront, this will be Lambda@edge,

and I have a lecture dedicated to this in this section.

CloudWatch Events or EventBridge.

This is whenever things happen in our infrastructure on AWS,

and we want to be able to react to things.

For example, say we have a cut pipeline,

state changes and we want to

do some automations based on it,

we can use a Lambda function.

CloudWatch Logs, to stream these logs,

wherever you want.

SNS to react to notifications and your SNS topics.

SQS to process messages from your SQS queues.

And finally Cognito to react to whenever,

for example, a user login to your database.

So, these are just the main ones.

There are tons of Lambda integrations.

And so I want to show you a very good example here,

which is a serverless thumbnail creation.

So let's say we have an S3 bucket,

and we want to create thumbnails on the fly.

So there will be an event

which is that the new image will be uploaded in Amazon S3.

This will trigger, through an S3 event notification,

a Lambda function.

And that Lambda function will have code

to generate a thumbnail.

That thumbnail maybe pushed and uploaded

into another S3 bucket or the same S3 bucket,

which would be a smaller version of that image.

And also, our Lambda function may want to

insert some data into DynamoDB,

around some metadata for the image,

for example the image, name, size, creation date,

et cetera, et cetera.

And so thanks to Lambda, we've automated

and had a reactive architecture

to the events of new app, new images being created in S3.

Another example that's extremely popular

is a serverless CRON drop.

So CRON is a way on your EC2 instances, for example,

to generate jobs every five minutes,

or every Monday at 10:00 AM, et cetera, et cetera.

But you need to run CRON on a virtual server.

So an ECE two instance and so on.

And so while your instance is not running,

or at least your CRONs are not doing anything,

then your instance time is wasted.

And so, as such, you can create a CloudWatch Event rule

or an EventBridge rule

that will be triggered every 1 hour.

And every 1 hour it will be integrated

with a Lambda function that will perform your task.

So this is a way to create a serverless CRON,

because in this example, CloudWatch Events is serverless

and Lambda functions are serverless too.

Now let's take an example at the Lambda pricing.

So you can find all the information on this website

in case the information here is outdated

but it will give you an example of how that works.

So you pay per calls.

The first 1 million requests are free,

and then you're going to pay 20 cents

per extra 1 million requests.

So that makes a very, very cheap request.

Then you're going to pay per duration

in increments of 1 (audio cuts out) seconds.

So you get the first 400,000 gigabytes-seconds

of compute time per month for free.

And then, what that means, this gigabyte-seconds is

it means you get to 400, 000 seconds of execution

if the function has 1 gigabyte of RAM.

That means you get 8 times as more seconds

if the function has 8 times as less RAM,

so 128 gigabytes, megabytes of RAM.

And, after that, you're going to pay $1

for 600,000 gigabytes-seconds.

So to be honest, you can make the math,

it's usually very, very cheap

to run your code on Lambda.

So it's a very popular option to create your applications.

So that's it.

Now let's go into the hands-on

to get a feeling of how Lambda works.

# AWS Lambda - First Hands On.

Okay,

so we're going to practice using the Lambda service.

And when you go in Lambda, you may end up on this screen,

but there's another screen I really like.

And so if you're in your URL,

you replace /discover by /begin,

you may end up on this screen,

which I really like because it has an educational value

I want to show you.

So Lambda is here to help you run code

without thinking about servers,

and this makes it a truly serverless service.

So the idea is that we can use any type

of programming language we want.

For example, .Net Core, Go, Java, Node JS, Python, Ruby,

or any custom runtime,

if you want to have a runtime provided by an open source,

for example, the Lambda Rust Runtime is possible.

And so from this code, you will have it written,

upload it into the Lambda console,

and then AWS Lambda will run the code for you.

So let's take a very simple code.

For example, Python, we have a Lambda handler,

it's going to print the event,

and then say, "Return Hello from Lambda."

So let's click on Run and we get Hello from Lambda.

So that means that the Lambda function just ran the code

that we have provided right here.

Very simple, right?

Next, how does Lambda functions get invoked?

So we can click on the Run button obviously,

but also, we can have Lambda respond to events.

And this is what I want to show you,

I think it's really cool.

So as we can see, events can come from various sources.

For example, in this one, this is streaming analytics.

And so as the streaming analytics is sending events

into a Lambda function,

the Lambda function is returning Hello from Lambda,

Hello from Lambda, Hello from Lambda,

and so on.

But it's not just those streaming analytics.

If you click on the phone right here,

it's going to send a message into a mobile IoT backend.

And this IoT backend will also invoke our Lambda function.

Same for if we take a photo,

and upload it into an S3 bucket for data processing,

then the Lambda function will be invoked.

But the cool thing is that

if you start clicking a lot on one of these sources,

you can see on the right hand side, we have more cog wheels.

So as the left hand side flow,

and invocations of Lambda scales,

then the number of Lambda invocations,

and concurrent Lambda functions running

will be scaling as well.

So it's really cool because that means that

as we have more load,

automatically Lambda will scale with our load.

And that is a whole power of using Lambda

as a compute platform,

and this is why Lambda is serverless,

and it scales really well.

So if we go in here, as we can see,

as the Lambda function is invoked,

we get more invocations over time,

and the cost remains zero because there's a free tier.

And as soon as we will pass 1 million invocations,

then the Lambda function will start incurring some charges.

So if we go in there and start having

over 1 million invocations, here we go,

now, we're getting some cents.

As you can see, we are at almost 2 million invocations,

and we have only 14 cents as a cost.

So it's very, very, very cost-efficient

to have a Lambda function and to run some workload at scale.

So as you can see, you can play around,

and seeing that the more you have invocations,

the more the cost goes, but it's really, really controlled.

And Lambda is, can be quite a cost-saving mechanism

if you use it at scale.

So this is just for the introduction to Lambda.

So if I click on create a function,

I can choose between three options,

and I'm going to choose to use a blueprint for this one.

And it's going to be the hello world function.

So I'm just going to search by hello world,

and then I will choose the Python version.

So Python 3.10 in this example,

but this could be a different version for you,

as long as it's Python.

Next, for the function name,

we're going to enter demo-lambda,

and then we're going to create a new role

with basic Lambda permissions.

This is going to be the IAM role of our Lambda function.

Then we can have a look at the function code.

So this is what a Lambda function looks like.

So we have a Lambda handler.

This is the function actually handles the event

of invoking our Lambda function.

And right now, it just prints a bunch

of values and returns the key1.

So we'll have a look at this in details

when we test our function.

So when you're ready, just click on create function.

Okay, so my function is created and as we can see,

the code has the code source in here.

And if I click on lambda function.py and open it,

we can see that the function code we had

from before is now loaded into this code editor.

So why don't we go ahead and test the function.

So I'm going to click on test and we need

to create a new test event, which is a hello world event,

which contains key1, value1, key2, value2, key3, value3

as adjacent documents.

So I'll call this one DemoEvent,

and click on Create.

So now, the demo event was successfully saved.

So if I click on test now,

it was going to run the DemoEvent,

and the response is value1,

the function log is that value1 equals value1,

value2 equals value2, value3 equals value3,

which is just a result of this, three print statements.

And finally, the response value is value1,

again, due to this line of code.

So it may not look like a match,

but from a programmer's perspective, as you can see,

you had just some code and it was uploaded into Lambda,

and then it was run by Lambda very quickly.

So this is a huge improvement if you're a developer,

as you can see, to deploy the code and have it run.

And on top of it, it runs seamlessly,

and it will scale automatically and it is fully serverless.

Okay?

We didn't deploy any servers.

Now, in terms of build duration,

so if you go in here and scroll down, sorry.

Then as you can see, the duration was 2.32 millisecond.

We've been billed for three millisecond of execution,

and here's the memory size that we've provisioned,

and the one that was used and how much the init was,

because this is the first time that

we used our Lambda function.

Now, if I run it again, oops,

if I go back to my function, excuse me,

and run this one again, as we can see now,

the function duration was 1.33 millisecond.

And on the right hand side, there was no initiation,

because my Lambda function was ready to be used.

Okay?

So that's one way of doing things.

Now, the other thing I'm going to show you is that

from this Lambda function, we're able to configure it.

So if I go into general configuration,

we get some of the most important settings.

The first one is around memory.

So we can have the memory from anywhere

between 128 megabytes up to 10,240 megabytes of memory.

Obviously, if you have more memory,

you're going to get billed more.

In terms of timeouts,

we can go anywhere between three seconds or five seconds,

all the way to, as you can see, 15 minutes.

So the maximum timeout is 15 minutes,

but you wanna make sure that you're only using the function

for the time that you think it's going to be used for.

And then the execution role is the one that was created

by Lambda in the beginning.

Okay, so those are some of the most important settings.

Okay?

And the other thing we can look at is monitoring.

So in monitoring, we're able to see

what is going on with the Lambda function,

so how many times it was invoked.

So here, one time, how long it lasted,

whether or not there was errors or successes and so on.

So it could be quite helpful.

But we have integration with CloudWatch,

metrics and also CloudWatch Logs.

So right now, we have nothing but we could look

at the CloudWatch Logs right now when the function runs.

So to do so, just refresh on the right hand side

the recent invocations and we can see

that there's a log stream right here.

So if I click on it,

I am taken directly into the CloudWatch Logs,

and we can see that on the CloudWatch Logs,

we have all the logs of the invocation

of this Lambda function.

And this is within a log group

called AWS Lambda, Demo Lambda,

and Demo Lambda is the name

of my Lambda function within my region, obviously.

And we have one log stream right here.

So we get all the logs into Lambdas.

And other things you can try is to modify the code.

For example, if we take this code,

we go to the Lambda function,

and I will comment this line of code

by having a hashtag and uncomment this one,

this is going to raise an exception.

So to do so, I need to first deploy the changes

by clicking on Deploy.

Now, the changes have been deployed,

and now, I can test my function.

And in this type, we get a execution result,

which is an error where something went wrong,

type is exception, as we can see,

something went wrong which was triggered

by this code or line of code right here.

So any type of errors also will be reported by Lambda,

and you could look into CloudWatch Logs

to understand as well where the log of the error happens.

So if I go back into CloudWatch Logs,

there's a second log stream right here,

which I'm going to open and we get

this exception right here.

So it's possible for us to go back as well to the logs

of the exception within CloudWatch Logs

to understand the root cause of the issue.

So fairly easy.

Now, if you wanna make the function run again fine,

you just reverse what you did and you click on Test.

And again, now, this time,

this Lambda execution function will work.

So some of the last things we may want to check out

is the fact that in here, the runtime settings,

we're running Python 3.7 in this example,

but you may get an updated version maybe on your end.

And the handler is lambda function.lambda handler,

which is saying to look at the lambda function.py file,

and the function named lambda handler.

So if you go up, you can see the function name

is the lambda_function.py,

and within it, we have the lambda_handler function.

So this is why it knew to invoke this function particularly.

Also, we have written to CloudWatch Logs.

And the reason we were able to do so

is that if we go into the configuration of our Lambda,

and go to the permissions tabs,

we have a role name called demo lambda role

that was created for us by the Lambda console.

And if you look at the policy itself,

we can see within the policy summary

that we have access to write to CloudWatch Logs,

which is something you can also see right here

by resource summary,

that CloudWatch Log has three actions and two resources,

which allow us to create log stream,

and log groups and also send the logs to CloudWatch Logs.

So this is the whole idea

behind this permissions tabs right here.

So that's it for this lecture.

I hope you liked it.

And if you are in the certified developer course on AWS,

then get ready for an extra few hours of content on Lambda.

And if you're not, well, this is enough for your exam.

I hope you liked it, and I will see you in the next lecture.

