So let's talk about Amazon Aurora

because the exam is starting to ask you a lot

of question about it.

Now, you don't need deep knowledge on it,

but you need enough high level overview

to understand exactly how it works.

So this is what I'm going to give you in this lecture.

Aurora is going to be a proprietary technology from AWS.

It's not open sourced,

but they made it so it's going to be compatible

with Postgres and MySQL and basically your Aurora database

will have compatible drivers.

That means that if you connect as if you were connecting

to your Postgres or MySQL database, then it will work.

Aurora is very special and I won't go too deep

into the internals, but they made it cloud optimized

and by doing a lot of optimization and smart stuff,

basically they get 5x performance improvements

over MySQL on the RDS or 3x performance of Postgres on RDS.

Not just that, but in many different ways,

they also get more performance improvements.

To me, I've watched it, it's really, really smart

but I won't go into the details of it.

Now Aurora storage automatically grows

and I think this is one of the main features

that is quite awesome.

You start at 10GB, but as you put more data

into your database it grows automatically up to 128TB.

Again, this has to do with how to design it

but the awesome thing is that now as a DB or a SysOps,

you don't need to worry about monitoring your disc.

You just know it will grow automatically with time.

Aurora can have up to 15 read replicas,

and the replication process is going

to be faster than MySQL.

You will see sub 10 ms replica lag typically.

Now if you do failover in Aurora

it was going to be instantaneous,

so it's gonna be much faster

than a failover from Multi-AZ on MySQL RDS.

And because it's cloud-native,

by default you get high availability.

Now, although the cost is a little bit more than RDS,

about 20% more, it is so much more efficient

that at scale it makes a lot more sense for savings.

So let's talk about the aspect that are super important

which is high availability and read scaling.

So Aurora is special because it's going to store six copies

of your data anytime you write anything across 3 AZ.

And so Aurora is made such as it's available,

so it only needs four copy out of six for writes.

So that means that if one AZ is down, you're fine.

And it only needs to have three copy

out of six needed for reads.

So again, that means that it's highly available for reads.

There is some kind of self healing process that happens

which is quite cool, which is that if some data

is corrupted or bad, then it does self healing

with peer-to-peer replication in the backend

and it's quite cool.

And you don't rely on just one volume,

you rely on 100s of volumes.

Again, not something for you to manage.

It happens in the backend, but that means

that you just reduce the risk by so much.

So if you look at it from a diagram perspective

you have 3 AZ and you have a shared storage volume

but it's the logical volume and it does replication,

self healing, and auto expanding,

which is a lot of features.

So if you were to write some data, maybe blue data,

you'll see the six copy of it in three different AZ.

Then if you write some orange data again six copy of it

in different AZ and then as you write more and more data,

it's basically going to go again six copy of it

in three different AZ.

The cool thing is that it goes on different volumes

and it's striped and it works really, really well.

Now we need to know about storage and that that's it.

But you don't actually interface with the storage.

It's just a design that Amazon made and I want

to give it to you as well so you understand

what Aurora takes.

Now, Aurora is like multi-AZ for RDS.

Basically there's only one instance that takes writes.

So there is a master in Aurora

and that's where we'll take writes.

And then if the master doesn't work

the failover will happens

in less than 30 seconds on average.

So it's really, really quick failover.

And on top of the master you can have

up to 15 read replicas all serving reads.

So you can have a lot of them

and this is how you scale your read workload.

And so any of these read replicas can become the master

in case the master fails.

So it's quite different from how RDS works

but by default you only have one master.

The cool thing about these read replicas is

that it supports cross region replication.

So if you look at Aurora on the right hand side of diagram,

this is what you should remember.

One master, multiple read replicas

and the storage is gonna be replicated, self-healing,

auto expanding, little blocks by little blocks.

Now let's have a look at how Aurora is as a cluster.

So this is more around how Aurora works

when you have clients.

How do you interface with all these instances?

So as we said, we have a shared storage volume

which is auto expanding from 10GB to 128GB.

Your master is the only thing

that will write to your storage.

And because the master can change and failover,

what Aurora provides you is what's called a writer endpoint.

So it's a DNS name, a writer endpoint,

and it's always pointing to the master.

So even if the master fails over,

your client still talks to the writer endpoint

and is automatically redirected to the right instance.

Now, as I said before, you also have a lot of read replicas.

What I didn't say is that they can have auto scaling

on top of these read replicas.

So you can have one up to 15 read replicas

and you can set up auto scaling

such as you always have the right number of read replicas.

Now, because you have auto scaling,

it can be really, really hard for your applications

to keep track of where are your read replicas.

What's the URL?

How do I connect to them?

So for it, you have to remember this absolutely

for going for the exam.

There is something called a reader endpoint.

And a reader endpoint has the exact same feature

as a writer endpoint.

It helps with connection load balancing

and it connects automatically to all the read replicas.

So anytime the client connects to the reader endpoints

it will get connected to one of the read replicas

and there will be load balancing done this way.

Make sure, just notice that the load balancing happens

at the connection level, not the statement level.

So this is how it works for Aurora.

Remember writer endpoint, reader endpoint.

Remember auto scaling.

remember shared storage volume that auto expands.

Remember this diagram 'cause once you get it,

you'll understand how Aurora works.

Now if we go deep into the feature

you get a lot of things I already told you.

Automatic failover, backup and recovery,

isolation and security, industry compliance,

push-button scaling by auto scaling,

automated patching with zero downtime.

So it's kind of cool that magic they do in the backend.

Advanced monitoring, routine maintenance,

so all these things are handled for you.

And you also get this feature called backtrack

which is giving you the ability

to restore data at any point of time.

And actually doesn't rely on backups,

it relies on something different.

But you can always say, I want to go back

to yesterday at 4:00 PM and you say, "Oh no,

actually I wanted to do yesterday at 5:00 PM,"

and it will work as well, which is super, super neat.

So that's it for Aurora,

and I will see you in the next lecture.

So let's go ahead and create

an Amazon Aurora database.

Now, just so you know, if you follow along with me

with this hands-on, it's going to cost you a bit of money.

The most important thing for you is to just

follow the instructions and to see what the options are.

But you don't need to actually go ahead

and create the database

if you don't have some money to spare for it.

So we're going to choose a standard create.

And as you can see we have two different options for Aurora,

we have the MySQL-compatible option

and the PostgresSQL-compatible option.

For this hands-on, I'm going to use MySQL.

I will scroll down and here you have to choose a version.

So you have a version selector right here.

And you can have filters, for example,

to only show the version that supports

the global database feature,

or the ones that support the parallel query feature

or the ones that support Serverless v2 feature.

So what I'm going to do is I'm going to keep

the default version as proposed by the Aurora console,

which is 3.04.1.

But this may be a different version for you.

Next, I will choose a template

and basically choosing production

allows me to configure everything.

So this is what we want to do.

We'll choose production.

For the DB cluster identifier in RDS,

we'll choose database two.

We have the master username being admin,

and then you can enter a password,

which I will right now.

Okay, then for cluster storage configuration,

you have two options.

You can have Aurora standard or IO optimized.

So if you have high input and output operations,

read and write operations on your Aurora database

you may want the IO optimized.

But for cost-effective workloads

that don't use Aurora too much,

then you may want to use Aurora standard.

Now for instance configuration,

you have the possibility of choosing

the class of instance you want for your database.

So you can see you have different ones

that can be memory optimized.

You have the burstable classes and you can choose

to include the previous generation classes,

it works sometimes.

But for now I'll just use db.t3 medium.

And also if you use a version

that is compatible with serverless,

you will see the Serverless v2 two option here.

And in here you don't select the instance type,

you just select what's called an Aurora capacity unit,

ACU, and you say, well, there is a minimum ACU you want

and the maximum ACU you want

and this will allow your database to scale

between these two capacity units automatically.

So for now, I'm going to use burstable classes

of db.t3 medium.

Now for availability and durability,

we have the option to have Aurora replicas.

So here we create an Aurora replica

and a reader node in a different AZ,

which is going to give us availability,

enhanced availability, as well as better reads

across AZ and fast failovers.

So this will cost more money,

but at least I can show you the full power of Aurora.

Next, for compute resource, we are not going to connect

to an EC2 resource.

We're going to choose a network type of IPv4,

this is going to be enough for our needs,

but if you have IPv6 as well in your VPC,

you can use dual stack mode.

Then you are going to be in the VPC.

That is the default VPC with the default submit group.

I will yes, allow public access to allow access

to the Aurora database from a public IP.

And for VPC security group, I'm going to create a new one

and I will call it demo database Aurora,

which will allow us to connect to our Aurora database.

Next, for additional configuration,

we can see that the database port is 3306,

which is the MySQL port.

If you selected MySQL before.

So we have the option to also have local write forwarding

in case the rights are applied to the read replica.

Then they will be forwarded automatically

to the write instance.

This is allowing you to have

an easier connection management.

Now, we can also have database authentication,

to use IAM based database application

or Kerberos based to basically authenticate a user

using an external mechanism.

We have enhanced monitoring.

I can disable it because we don't need it.

And we have additional options for your database.

For example, the initial database name is going to be my DB,

and then backup retention is going to be one day.

This is great.

We can have encryption for our database.

We have several options around backtracking

to rewind our database,

and log exports, but I will not go over them.

We have deletion protection

to protect the database from being accidentally deleted,

but everything looks fine now.

And as you can see, we have some monthly costs.

So make sure that you are aware of this

by creating this Aurora database.

So let's go ahead and create this database.

So my Aurora database is created.

And as we can see, we have a regional cluster

with a writer instance and a reader instance.

So here, the important fact is that

we have different instance to write and to read from,

and there are in different AZ.

So this is the whole power of Aurora.

So if you click on database two, as we can see

to connect, we have two endpoints.

We have a reader endpoints and a writer endpoints.

So these endpoints are very handy

because they represent an endpoint

that will always lead to the right writer instance.

And this endpoint will always lead

to the right reader instance.

So these endpoints is what your application

should be using to connect to Aurora.

But if you were to click directly

on this specific instance right here,

this instance would have also a dedicated endpoint.

And that instance over here would also have

a dedicated endpoint once it is being created.

So it's still being in the creating space.

Okay, so we have these feature that are cool.

Then, we have other features,

so we can add more readers into our reader cluster

to add on with scaling capacity.

And we can also create a cross-region read replica

if you want to have a replica in another region.

We can restore in point in time.

And another one is that we could add replica auto-scaling.

So this one is very important

because well, we can create a policy.

And this policy would say, Hey,

based on the average utilization of your Aurora replica

or the average number of connections to your Aurora replica,

then scale your read replica.

So say read replica scaling policy.

And say, okay, I want to make sure that my read replica

stay at the target value of 60%.

And if I go over, please create more read replica.

We could also define a scaling period

for the scaling policy, which makes sense.

And what's the min and the max capacity.

So one replica up to 15 Aurora replicas.

And this is very handy to have a Read replica

Auto-scaling as a database.

So I cancel it, we don't need it right now.

And now I've made sure that both my points,

my database and endpoints are available.

So we're good to go.

So one last thing I can do

to show you the whole power of Aurora

is to do action and add AWS region.

And this is only possible if you chose a version of Aurora

that was enabled with the global database feature.

But here we can add the database region to other regions,

and this will allow you to get a global Aurora.

Now, as you can see, this is not possible with this cluster

because we need to have an instance

with a compatible size to do this first.

So we need to change the instance, for example,

to a large type of instance,

and then we would be able to add other regions

to the database cluster.

But anyway, I wanted to show you the feature right here.

Okay, so that's it for Aurora.

This is pretty much what you get,

which is an amazing database with amazing performance,

great, great scaling capacity, global and so on serverless.

So really, really complete database.

I really like this offering from AWS.

Now to be done with this hands-on, just take this database

and you want to delete it,

but as you can see, it's not available.

So what you need to do first

is to delete the reader instance.

So type delete me.

Then you need to delete the writer instance.

So again, action, delete, and then you type delete me.

And then once both these things are deleted,

you are going to be able to delete your whole cluster.

So I will wait when it's done.

That's it.

My database is now deleted,

and I will see you in the next lecture.

